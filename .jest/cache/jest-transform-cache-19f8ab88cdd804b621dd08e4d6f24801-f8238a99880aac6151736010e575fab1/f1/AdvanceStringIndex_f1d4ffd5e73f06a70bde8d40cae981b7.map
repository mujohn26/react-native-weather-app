{"version":3,"sources":["AdvanceStringIndex.js"],"names":["GetIntrinsic","require","CodePointAt","IsInteger","Type","MAX_SAFE_INTEGER","$TypeError","module","exports","AdvanceStringIndex","S","index","unicode","length","cp"],"mappings":"AAAA;;AAEA,IAAIA,YAAY,GAAGC,OAAO,mBAA1B;;AAEA,IAAIC,WAAW,GAAGD,OAAO,iBAAzB;;AACA,IAAIE,SAAS,GAAGF,OAAO,eAAvB;;AACA,IAAIG,IAAI,GAAGH,OAAO,UAAlB;;AAEA,IAAII,gBAAgB,GAAGJ,OAAO,6BAA9B;;AAEA,IAAIK,UAAU,GAAGN,YAAY,CAAC,aAAD,CAA7B;;AAIAO,MAAM,CAACC,OAAP,GAAiB,SAASC,kBAAT,CAA4BC,CAA5B,EAA+BC,KAA/B,EAAsCC,OAAtC,EAA+C;AAC/D,MAAIR,IAAI,CAACM,CAAD,CAAJ,KAAY,QAAhB,EAA0B;AACzB,UAAM,IAAIJ,UAAJ,CAAe,wCAAf,CAAN;AACA;;AACD,MAAI,CAACH,SAAS,CAACQ,KAAD,CAAV,IAAqBA,KAAK,GAAG,CAA7B,IAAkCA,KAAK,GAAGN,gBAA9C,EAAgE;AAC/D,UAAM,IAAIC,UAAJ,CAAe,iEAAf,CAAN;AACA;;AACD,MAAIF,IAAI,CAACQ,OAAD,CAAJ,KAAkB,SAAtB,EAAiC;AAChC,UAAM,IAAIN,UAAJ,CAAe,+CAAf,CAAN;AACA;;AACD,MAAI,CAACM,OAAL,EAAc;AACb,WAAOD,KAAK,GAAG,CAAf;AACA;;AACD,MAAIE,MAAM,GAAGH,CAAC,CAACG,MAAf;;AACA,MAAKF,KAAK,GAAG,CAAT,IAAeE,MAAnB,EAA2B;AAC1B,WAAOF,KAAK,GAAG,CAAf;AACA;;AACD,MAAIG,EAAE,GAAGZ,WAAW,CAACQ,CAAD,EAAIC,KAAJ,CAApB;AACA,SAAOA,KAAK,GAAGG,EAAE,CAAC,mBAAD,CAAjB;AACA,CAnBD","sourcesContent":["'use strict';\n\nvar GetIntrinsic = require('../GetIntrinsic');\n\nvar CodePointAt = require('./CodePointAt');\nvar IsInteger = require('./IsInteger');\nvar Type = require('./Type');\n\nvar MAX_SAFE_INTEGER = require('../helpers/maxSafeInteger');\n\nvar $TypeError = GetIntrinsic('%TypeError%');\n\n// https://ecma-international.org/ecma-262/6.0/#sec-advancestringindex\n\nmodule.exports = function AdvanceStringIndex(S, index, unicode) {\n\tif (Type(S) !== 'String') {\n\t\tthrow new $TypeError('Assertion failed: `S` must be a String');\n\t}\n\tif (!IsInteger(index) || index < 0 || index > MAX_SAFE_INTEGER) {\n\t\tthrow new $TypeError('Assertion failed: `length` must be an integer >= 0 and <= 2**53');\n\t}\n\tif (Type(unicode) !== 'Boolean') {\n\t\tthrow new $TypeError('Assertion failed: `unicode` must be a Boolean');\n\t}\n\tif (!unicode) {\n\t\treturn index + 1;\n\t}\n\tvar length = S.length;\n\tif ((index + 1) >= length) {\n\t\treturn index + 1;\n\t}\n\tvar cp = CodePointAt(S, index);\n\treturn index + cp['[[CodeUnitCount]]'];\n};\n"]}